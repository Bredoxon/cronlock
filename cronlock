#!/usr/bin/env bash
# cronlock - https://github.com/kvz/cronlock
# Use a central redis instance to globally lock cronjobs across a distributed system
#
# Licensed under MIT
# Copyright 2012 by Kevin van Zonneveld (http://kevin.vanzonneveld.net)
# Contains code from https://github.com/reinh/redis.bash
#
# Readme:
# - web: https://github.com/kvz/cronlock/blob/master/README.md
# - cli: wget -O- --no-check-certificate https://raw.github.com/kvz/cronlock/master/README.md

[ -z "${CRONLOCK_HOST}" ]    && CRONLOCK_HOST="localhost"
[ -z "${CRONLOCK_PORT}" ]    && CRONLOCK_PORT=6379
[ -z "${CRONLOCK_GRACE}" ]   && CRONLOCK_GRACE=40
[ -z "${CRONLOCK_RELEASE}" ] && CRONLOCK_RELEASE=86400
[ -z "${CRONLOCK_KEY}" ]     && CRONLOCK_KEY="$(echo "$@" | md5)"
[ -z "${CRONLOCK_PREFIX}" ]  && CRONLOCK_PREFIX="cronlock."
[ -z "${CRONLOCK_VERBOSE}" ] && CRONLOCK_VERBOSE="no"
[ -z "${CRONLOCK_RESET}" ]   && CRONLOCK_RESET="no"

CRONLOCK_KEY="${CRONLOCK_PREFIX}${CRONLOCK_KEY}"

function info {
  if [ "${CRONLOCK_VERBOSE}" = "yes" ]; then
    echo "${1}"
  fi
}
function fatal {
  echo "${1}"
  exit 201
}

function cmd {
  exec 3<>/dev/tcp/${CRONLOCK_HOST}/${CRONLOCK_PORT} || fatal "Redis down"
  { printf "${1}\r\n"; sleep 0.01; } >&3 # sleep to avoid a socket close race condition.

  # Parse the response according to redis protocol
  read -r response <&3
  case $response in
    +*) # Status
      echo "${response#+}"
      ;;
    -*) # Error
      echo "${response#-}" >&2
      exit 1
      ;;
    :*) # Integer
      echo "${response#:}"| tr -d '\n\r\0\t'
      ;;
    \$*) # Bulk reply
      nchars="$(echo "${response#\$}"| tr -d '\n\r\0\t')"
      nchars="$(echo "${nchars%\r}"| tr -d '\n\r\0\t')"
      read -n $nchars response <&3
      echo $response
      ;;
    *) # net yet handled
      echo "ERR - Unknown response\n" >&2
      exit 2
      ;;
    esac
}

cmd "INFO" |grep version > /dev/null || fatal "Redis was not found at '${CRONLOCK_HOST}' port '${CRONLOCK_PORT}'. Please install, or see README for targeting a different host"

if [ "${CRONLOCK_RESET}" = "yes" ]; then
  removed="$(cmd "DEL ${CRONLOCK_KEY}")"
  if [ "${removed}" = "1" ] || [ "${removed}" = "0" ]; then
    exit 200
  else
    fatal "Unable to remove ${CRONLOCK_KEY}"
  fi
fi

let "expire_at_min = $(date -u "+%s") + ${CRONLOCK_GRACE} + 1"
let "expire_at_max = $(date -u "+%s") + ${CRONLOCK_RELEASE} + 1"
acquired="$(cmd "SETNX ${CRONLOCK_KEY} ${expire_at_max}")"

if [ "${acquired}" = "1" ]; then
  info "Cronlock ${CRONLOCK_KEY} acquired by me"
elif [ "${acquired}" = "0" ]; then
  expires_at="$(cmd "GET ${CRONLOCK_KEY}")"
  let "expires_in = ${expires_at} - $(date -u "+%s")"

  if [ "${expires_in}" -gt "0" ]; then
    info "Cronlock ${CRONLOCK_KEY} was already acquired (expires in ${expires_in}s)"
    exit 200
  fi

  if [ "${expires_in}" -eq "0" ]; then
    info "Cronlock ${CRONLOCK_KEY} was already acquired but expiring now!"
  else
    info "Cronlock ${CRONLOCK_KEY} was already acquired but expired ${expires_in#-}s ago"
  fi

  respire="$(cmd "GETSET ${CRONLOCK_KEY} ${expire_at_max}")"
  let "expires_in = ${respire} - $(date -u "+%s")"
  if [ "${expires_in}" -gt "0" ]; then
    info "Cronlock ${CRONLOCK_KEY} was just now acquired by a different box (expires in ${expires_in}s)"
    exit 200
  fi
else
  fatal "Unexpected return value while acquiring Cronlock: ${CRONLOCK_KEY} at: ${CRONLOCK_HOST}"
fi

$@
exitcode=${?}
grace="$(cmd "GETSET ${CRONLOCK_KEY} ${expire_at_min}")"
exit $exitcode
