#!/usr/bin/env bash
# cronlock - https://github.com/kvz/cronlock
# Use a central redis server to globally lock cronjobs across a distributed system
#
# Licensed under MIT
# Copyright 2012 by Kevin van Zonneveld (http://kevin.vanzonneveld.net)
# Contains code from https://github.com/reinh/redis.bash
#
# Readme:
# - web: https://github.com/kvz/cronlock/blob/master/README.md
# - cli: curl https://raw.github.com/kvz/cronlock/master/README.md

function info {
  if [ "${CRONLOCK_VERBOSE}" = "yes" ]; then
    echo "${1}"
  fi
}
function fatal {
  echo "${1}"
  exit 201
}
function cmd {
  exec 3<>/dev/tcp/${CRONLOCK_HOST}/${CRONLOCK_PORT} || fatal "Redis down"
  { printf "${1}\r\n"; sleep 0.01; } >&3 # sleep to avoid a socket close race condition.

  # Parse the response according to redis protocol
  read -r response <&3
  case $response in
    +*) # Status
      echo "${response#+}"
      ;;
    -*) # Error
      echo "${response#-}" >&2
      exit 201
      ;;
    :*) # Integer
      echo "${response#:}"| tr -d '\n\r\0\t'
      ;;
    \$*) # Bulk reply
      nchars="$(echo "${response#\$}"| tr -d '\n\r\0\t')"
      nchars="$(echo "${nchars%\r}"| tr -d '\n\r\0\t')"
      read -n $nchars response <&3
      echo $response
      ;;
    *) # net yet handled
      echo "ERR - Unknown response\n" >&2
      exit 201
      ;;
    esac
}

# Set magic variables for current FILE & DIR
__FILE__="$(test -L "$0" && readlink "$0" || echo "$0")"
__DIR__="$(dirname "${__FILE__}")"

# Try different locations for config file unless CRONLOCK_CONFIG was set
TRY="${__DIR__}/cronlock.conf"
[ -z "${CRONLOCK_CONFIG}" ] && [ -f "${TRY}" ] && CRONLOCK_CONFIG="${TRY}"
TRY="/etc/cronlock.conf"
[ -z "${CRONLOCK_CONFIG}" ] && [ -f "${TRY}" ] && CRONLOCK_CONFIG="${TRY}"

# Include config file
if [ -n "${CRONLOCK_CONFIG}" ]; then
  info "Including config from ${CRONLOCK_CONFIG}"
  source "${CRONLOCK_CONFIG}"
fi

# Defaults
[ -z "${CRONLOCK_HOST}" ]    && CRONLOCK_HOST="localhost"
[ -z "${CRONLOCK_PORT}" ]    && CRONLOCK_PORT=6379
[ -z "${CRONLOCK_GRACE}" ]   && CRONLOCK_GRACE=40
[ -z "${CRONLOCK_RELEASE}" ] && CRONLOCK_RELEASE=86400
[ -z "${CRONLOCK_KEY}" ]     && CRONLOCK_KEY="$(echo "$@" | md5 2>/dev/null || echo "$@" | md5sum | awk '{print $1}')"
[ -z "${CRONLOCK_PREFIX}" ]  && CRONLOCK_PREFIX="cronlock."
[ -z "${CRONLOCK_VERBOSE}" ] && CRONLOCK_VERBOSE="no"
[ -z "${CRONLOCK_RESET}" ]   && CRONLOCK_RESET="no"
[ -z "${CRONLOCK_NTPDATE}" ] && CRONLOCK_NTPDATE="no"

# Setup the key
CRONLOCK_KEY="${CRONLOCK_PREFIX}${CRONLOCK_KEY}"

# Sync time
if [ "${CRONLOCK_NTPDATE}" = "yes" ]; then
  if [ -x "$(which ntpd)" ]; then
    info "Ignoring request to synchronize time as ntpd is installed which does this continously. "
  else
    sudo ntpdate pool.ntp.org
  fi
fi

# Test redis connection
cmd "INFO" |grep version > /dev/null || fatal "Redis was not found at '${CRONLOCK_HOST}' port '${CRONLOCK_PORT}'. Please install, or see README for targeting a different host"

# Reset mode
if [ "${CRONLOCK_RESET}" = "yes" ]; then
  removed="$(cmd "DEL ${CRONLOCK_KEY}")"
  if [ "${removed}" = "1" ] || [ "${removed}" = "0" ]; then
    exit 200
  else
    fatal "Unable to remove ${CRONLOCK_KEY}"
  fi
fi

# Grace periods
let "expire_at_min = $(date -u "+%s") + ${CRONLOCK_GRACE} + 1"
let "expire_at_max = $(date -u "+%s") + ${CRONLOCK_RELEASE} + 1"

# Acquire
acquired="$(cmd "SETNX ${CRONLOCK_KEY} ${expire_at_max}")"

# Here come the edge cases
if [ "${acquired}" = "1" ]; then
  info "Cronlock ${CRONLOCK_KEY} acquired by me"
elif [ "${acquired}" = "0" ]; then
  expires_at="$(cmd "GET ${CRONLOCK_KEY}")"
  let "expires_in = ${expires_at} - $(date -u "+%s")"

  if [ "${expires_in}" -gt "0" ]; then
    info "Cronlock ${CRONLOCK_KEY} was already acquired (expires in ${expires_in}s)"
    exit 200
  fi

  if [ "${expires_in}" -eq "0" ]; then
    info "Cronlock ${CRONLOCK_KEY} was already acquired but expiring now. "
    exit 200
  else
    info "Cronlock ${CRONLOCK_KEY} was already acquired but expired ${expires_in#-}s ago"
  fi

  respire="$(cmd "GETSET ${CRONLOCK_KEY} ${expire_at_max}")"
  let "expires_in = ${respire} - $(date -u "+%s")"
  if [ "${expires_in}" -gt "0" ]; then
    info "Cronlock ${CRONLOCK_KEY} was just now acquired by a different box (expires in ${expires_in}s)"
    exit 200
  fi
else
  fatal "Unexpected return value while acquiring Cronlock: ${CRONLOCK_KEY} at: ${CRONLOCK_HOST}"
fi

# Execute original command
$@
exitcode=${?}

# Setup min-grace period to compensate for small jobs on inconstistent system clocks
grace="$(cmd "GETSET ${CRONLOCK_KEY} ${expire_at_min}")"

# Pass original command's exit code. Cronlock codes all exit above 200
exit $exitcode
