{"body":"# cronlock v0.1\r\n\r\n[![Build Status](https://secure.travis-ci.org/kvz/cronlock.png?branch=master)](http://travis-ci.org/kvz/cronlock)\r\n\r\n## Install\r\n\r\nOn most Linux & BSD machines, cronlock will install just by downloading it & making it executable.\r\nHere's the one-liner:\r\n\r\n```bash\r\nsudo curl -q https://raw.github.com/kvz/cronlock/master/cronlock -o /usr/bin/cronlock && sudo chmod +x $_\r\n```\r\n\r\nWith [Redis](http://redis.io/) present on `localhost`, cronlock should now already work in basic form.\r\nLet's test by letting it execute a simple `pwd`:\r\n\r\n```bash\r\nCRONLOCK_HOST=localhost cronlock pwd\r\n```\r\n\r\nIf this returns the current directory we're good to go. More examples below.\r\n\r\n## Introduction\r\n\r\nUses a central [Redis](http://redis.io/) server to globally lock cronjobs across a distributed system.\r\nThis can be usefull if you have 30 webservers that you deploy crontabs to (such as\r\nmailing your customers), but you don't want 30 cronjobs spawned.\r\n\r\nOf course you could also deploy your cronjobs to 1 box, but in volatile environments\r\nsuch as EC2 it can be helpful not to rely on 1 'throw away machine' for your scheduled tasks,\r\nand have 1 deploy-script for all your workers.\r\n\r\nAnother common problem that cronlock will solve is overlap by a single server/cronjob.\r\nIt happens a lot that developers underestimate how long a job will run.\r\nThis can happen because the job waits on something, acts different under high load/volume, or enters an endless loop.\r\n\r\nIn these cases you don't want the job to be fired again at the next cron-interval, making your problem twice as bad, \r\nsome intervals later, there's a huge `ps auxf` with overlapping cronjobs, high server load, and eventually a crash.\r\n\r\nBy settings locks, cronlock can also prevent the overlap in longer-than-expected-running cronjobs.\r\n\r\n## Design goals\r\n\r\n - Lightweight\r\n - As little dependencies as possible / No setup\r\n - Follows locking logic from [this Redis documentation](http://redis.io/commands/setnx)\r\n - Well tested & documented\r\n\r\n## Requirements\r\n\r\n - Bash with `/dev/tcp` enabled. Older Debian/Ubuntu systems disable `/dev/tcp`\r\n - `md5` or `md5sum`\r\n - A [Redis](http://redis.io/) server that is accessible by all cronlock machines\r\n\r\n## Options\r\n\r\n - `CRONLOCK_CONFIG` location of config file. this is optional since all config can also be\r\n passed as environment variables. default: `<DIR>/cronlock.conf`, `/etc/cronlock.conf`\r\n\r\nUsing the `CRONLOCK_CONFIG` file or by exporting in your environment, you can set these variables\r\nto change the behavior of cronlock:\r\n\r\n - `CRONLOCK_HOST` the Redis hostname. default: `localhost`\r\n - `CRONLOCK_PORT` the Redis port. default: `6379`\r\n - `CRONLOCK_GRACE` determines how many seconds a lock should at least persist.\r\n This is to make sure that if you have a very small job, and clocks aren't in sync, the same job\r\n on server2/3/4/5/6/etc (maybe even slightly behind in time) will just fire right after server1 releases the lock. default: `40` (I recommend using a grace of at least 30s)\r\n - `CRONLOCK_RELEASE` determines how long a lock can persist at most.\r\n Acts as a failsafe so there can be no locks that persist forever in case of failure. default is a day: `86400`\r\n - `CRONLOCK_KEY` a unique key for this command in the global Redis server. default: a hash of cronlock's arguments\r\n - `CRONLOCK_PREFIX` Redis key prefix used by all keys. default: `cronlock`\r\n - `CRONLOCK_VERBOSE` set to `yes` to print debug messages. default: `no`\r\n - `CRONLOCK_NTPDATE` set to `yes` update the server's clock againt `pool.ntp.org` before execution\r\n default: `no`\r\n\r\n## Examples\r\n\r\n### Single box\r\n\r\n```bash\r\ncrontab -e\r\n* * * * * cronlock ls -al\r\n```\r\n\r\nIn this configuration, `ls -al` will be launched every minute. If the previous\r\n`ls -al` has not finished yet, another one is not started.\r\nThis works on 1 server, as the default `CRONLOCK_HOST` of `localhost` is used.\r\n\r\nIn this setup, cronlock works much like [Tim Kay](http://timkay.com/)'s [solo](https://github.com/timkay/solo),\r\nexcept cronlock requires [Redis](http://redis.io/), so I recommend using Tim Kay's solution here.\r\n\r\n### Distributed\r\n\r\n```bash\r\necho '0 8 * * * CRONLOCK_HOST=redis.mydomain.com cronlock /var/www/mail_customers.sh' | crontab\r\n```\r\n\r\nIn this configuration, a central Redis server is used to track the locking for\r\n`/var/www/mail_customers.sh`. So you see that throughout a cluster of 100 servers,\r\njust one instance of `/var/www/mail_customers.sh` is ran every morning. No less, no more.\r\n\r\nAs long as your Redis server and at least 1 volatile worker is alive, this happens.\r\n\r\n### Distributed using a config file\r\n\r\nTo avoid messy crontabs, you can use a config file for shared config instead.\r\nUnless `CRONLOCK_CONFIG` is set, cronlock will look in `./cronlock.conf`, then\r\nin `/etc/cronlock.conf`.\r\n\r\nExample:\r\n```bash\r\ncat << EOF > /etc/cronlock.conf\r\nCRONLOCK_HOST=\"redis.mydomain.com\"\r\nCRONLOCK_GRACE=50\r\nCRONLOCK_PREFIX=\"mycompany.cronlocks.\"\r\nCRONLOCK_NTPDATE=\"yes\"\r\nEOF\r\n\r\ncrontab -e\r\n* * * * * cronlock /var/www/mail_customers.sh # will use config from /etc/cronlock.conf\r\n```\r\n\r\n### Lock commands even though they have different arguments\r\n\r\nBy default cronlock uses your command and it's arguments to make a unique identifier\r\nby which the global lock is acquired. However if you want to run: `ls -al` or `ls -a`,\r\nbut just 1 instance of either, you'll want to provide your own key:\r\n\r\n```bash\r\ncrontab -e\r\n# One of two will be executed because they share the same KEY\r\n* * * * * CRONLOCK_KEY=\"ls\" cronlock ls -al\r\n* * * * * CRONLOCK_KEY=\"ls\" cronlock ls -a\r\n```\r\n\r\n### Per application\r\n\r\nIf you use the same script and Redis server for multiple applications, an unwanted lock could deny app2 it's script.\r\nYou could make up your own unique `CRONLOCK_KEY` to circumvent, but it's probably \r\nbetter to use the `CRONLOCK_PREFIX` for that:\r\n\r\n```bash\r\ncrontab -e\r\n* * * * * CRONLOCK_PREFIX=\"mylocks.app1.\" cronlock /var/www/mail_customers.sh\r\n```\r\n\r\n```bash\r\ncrontab -e\r\n* * * * * CRONLOCK_PREFIX=\"mylocks.app2.\" cronlock /var/www/mail_customers.sh\r\n```\r\n\r\nNow both /var/www/mail_customers.sh will run, because they have a different application in their prefixes.\r\n\r\n## Exit codes\r\n\r\n - `200` Success (delete succeeded or lock not acquired, but normal execution)\r\n - `201` Failure (cronlock error)\r\n - < `200` Success (acquired lock, executed your command), passes the exit code of your command\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Cronlock","google":"UA-63083-8","tagline":"cronlock lets you deploy cronjobs cluster-wide without worrying about overlaps. It uses Redis to keep track of locks."}